db.<collection>.insertOne( <document> )
db.<collection>.insertMany( [ <doc1>, … , <docN> ] )
db.<collection>.findOne( <query filter>, <projection> )
db.<collection>.find( <query filter>, <projection> )
db.<collection>.updateOne( <query filter>, <update>, <options> )
db.<collection>.updateMany( <query filter>, <update>, <options> )
db.<collection>.deleteOne( <query filter>)
db.<collection>.deleteMany( <query filter> )

use("supplies")
db.sales.findOne()

db.<collection>.aggregate(
    <query filter>,
    <projection>
)

use("supplies")
db.sales.aggregate([
    {
        $match: {
            "storeLocation": {$in: ["London", "Austin", "San Diego"]},
            "customer.age": {$gte: 18},
            $and: [
                {"items.tags": {$in: ["school", "kids"]}},
                {"items.price": {$gte: 1000}}
            ]
        }
    },
    {
        $project: {
            "sale": "$_id", "fecha": "$saleDate", "storeLocation":1, 
            "mail_cliente": "$customer.email", "_id":0
        }
    }
])

$match es uno de varios filtros, se usa:
$match: {
    {   <field1>: { <operator>:<value> }
        <field2>: { <operator>:<value> }
        ...
    }
}

Si un campo tiene subcampos (bastante frecuente), se accede con .
ej: "customer.age"

Operadores para MATCH:
$eq, $nq, $gt, $gte, $lt, $lte, $in, $nin
(a $in y $nin se les da un array)

Se puede hacer una lista de conjunciones lógicas, con 
$and, $or, $not, $nor
Se dan dentro de un arreglo las condiciones:
$and: [
        {"items.tags": {$in: ["school", "kids"]}}, 
        {"items.price": {$gte: 1000}}
    ]

Matcheos entre campos de un mismo documento: (Interesante. Util.)
{ $match: { $expr: { $gt: [ "$spent" , "$budget" ] } }}

Si un campo es un arreglo, tiene también operadores para usarle:
$all: matchea si el campo arreglo contiene todos los elementos especificados en value
$elemMatch: matchea si al menos un elemento en el campo arreglo cumple todas las condiciones especificadas
$size: matchea si el campo arreglo es del largo especificado

Se puede matchear por nulo con <campo>:null, y por (in)existencia con <campo>: {$exists: true/false}
También por $type

------------------------------------------------------------------------------------------------------------------
$projection es para los campos que van a quedar, se usa:
$project: {
    <field1>: <value>, 
    <field2>: <value>
     ...
}

Se listan los campos que se quieren, con 1 para que aparezcan. _id está por default, 
se saca con "_id":0. Para hacer referencia a campos por el nombre se usa $, y para dar
un nombre distinto a un campo se lo pone adelante y se aclara a cual se refiere:
"fecha": "$saleDate", "mail_cliente": "$customer.email"

Antes o después de proyectar se puede usar sort, skip, limit, count:
.sort(
    {
        <field1>: <1 or -1>, ascendente o descendente
        <field2>: <1 or -1>,
        ...
    }
).skip( <offset>
).limit(<number>
).count(<campo a contar>)


------------------------------------------------------------------------------------------------------------------
Está addFields para crear campos en la pipeline de agregacion antes de entrar a matchear:
$addFields: { "avg_score": { $avg: "$results.score" } }
$addFields: { "nombre del nuevo campo": { $operador: "$nombre del campo que se usa" } }
Pueden ser varios campos, un operador tan complejo como se te cante

$unwind
Deconstruye un campo arreglo en el documento y crea documentos separados para cada elemento en el arreglo
$replaceRoot
Reemplaza el documento por un documento anidado especificado
No sé cuando se usaría la verdad
$group
Agrupa los documentos por una expresión especificada y aplica las expresiones acumuladoras
{ $group: {
        _id: <expression>,
        <field1>: { <accumulator1>: <expression1> },
        //$avg, $max, $min, $stdDevPop, $count, $sum, $first, $addToSet, $push, ...
    }
}
db.sales.aggregate([
    {
        $group: {
            _id: { "year": {$year: "$date"}, month: {$month: "$date" } },
            totalQuantity: { $sum: "$qty" },
            tamount: { $sum: { $multiply: [ "$price", "$qty" ] } },
            count: { $sum: 1 }
        }
    }
])


$unionWith
Realiza la unión de dos colecciones
{ $unionWith:  "<collection>" }
{ $unionWith:  { 
    coll: "<collection>",  
    pipeline: [ { <stage1> }, { <stage2> }, ... ] } 
}
db.cats.aggregate([
    {
        $unionWith: {
            coll: "dogs",
            pipeline: [ { $match: { weight: { $lt: 30 } } } ]
        }
    }
])


$out
Almacena el resultado del pipeline en una colección
$lookup
Realiza un left join a otra colección. No es complejo pero ver en filminas #9


VISTAS (ya sabemos qué hacen):
db.createView( 
    "<viewName>",
    "<source>",
    [ <pipeline> ]
)

------------------------------------------------------------------------------------------------------------------
Más CRUD, la parte CUD:
db.inventory.updateOne(
    { item: "paper" },
    {
        $set: { "size.uom": "cm", status: "P" },
        $currentDate: { lastModified: true }
    }
)

db.food.updateMany(
    { _id: { $in: [1, 3] } },
    {
        $addToSet: { fruits: { $each: ["cherry",
        "pear"] } }
    }
)

Upsert (Update + Insert)
Se lo setea a true para que si el documento a actualizar no está, se lo inserte. Si no
se lo especifica ya sabemos qué pasa
db.analytics.updateOne(
    { url: "/blog"},
    { $inc: { pageviews : 1 } },
    { upsert: true }
)

Delete
db.inventory.deleteMany(
    {status: "A"}
)

------------------------------------------------------------------------------------------------------------------
VALIDACIÓN
db.createCollection( "<name>", { validator: <document>, validationLevel: <string>, validationAction: <string> } )
db.runCommand( { collMod: "<name>",  validator: <document>, validationLevel: <string>, validationAction: <string> } )

db.createCollection("employees", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: [ "name", "age" ],
            properties: {
                name: {
                    bsonType: "string",
                    minLength: 3,
                    description: "full name of the employee and is required"
                },
                age: {
                    bsonType: "int",
                    minimum: 16,
                    description: "age of the employee and is required"
                },
                category: {
                    enum: [ "Full-time","Part-time", "Temporary" ],
                    description: "can only be one of the enum values if the field exists"
                }
            }
        }
    }, //OPCIONALES
    validationLevel: "strict", 
    validationAction: "error"
} )

bsonType
-> Acepta los mismos alias en string usados por el operador $type
required
-> El documento debe contener todos los elementos especificados en el arreglo
properties
-> Un esquema JSON válido donde cada valor es un esquema JSON válido
additionalProperties
-> Especifica si campos si se permiten campos adicionales
minimum, maximum
-> Indica el valor mínimo (máximo) del campo
minItems, maxItems
-> Indica la longitud mínima (longitud máxima) del arreglo

otros keywords: enum, description, pattern, minLength, maxLength, uniqueItems, más keywords en link de la filmina


validationLevel: especifica cómo aplicar las reglas de validación
    strict: (por defecto) Se aplican a todos los inserts y updates.
    moderate: Se aplican a los documentos existentes válidos. 
validationAction : Cómo manejar los documentos que no cumplen la validación
    error: (por defecto) Rechaza cualquier insert o update
    warn: No rechaza pero hace un log

Agregar una validación a una colección existente
db.runCommand( {
   collMod: "contacts",
   validator: { $jsonSchema: {
      bsonType: "object",
      required: [ "phone", "name" ],
      properties: {
         phone: {
            bsonType: "string",
            description: "phone must be a string and is required"
         },
         name: {
            bsonType: "string",
            description: "name must be a string and is required"
         }
      }
   } },
   validationLevel: "moderate",
   validationAction: "error"
} )

db.getCollectionInfos( "<collection>") ?? No me sale hacerlo andar

Honestamente, Mongo es una cagada. Es re potente y que se yo pero que sintaxis horrible por dio
